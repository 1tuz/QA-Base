Язык запросов для работы с базами данных. Используется для выборки, изменения и анализа данных.

- **SELECT:** выборка данных.
- **UPDATE:** обновление данных.
- **DELETE:** удаление данных.  
  
(ленивый) 
Проверял статусы заявок или логи пользователей. Основную нагрузку на базу вытягивали аналитики. 

Работал через интерфейсы PostgreSQL (PgAdmin), MySQL Workbench и DBeaver.

(сложный)
Использовал для проверки корректности данных, генерации отчетов по пользовательской активности. Иногда подбирал сложные SELECT-запросы для аналитиков или проверял данные в нескольких связанных таблицах. 

**Агрегатные функции** 
Чаще всего использовал `SUM`, `AVG`, `COUNT` для анализа платежей, кредитов, транзакций. Если надо посчитать по группам, использовал `GROUP BY`. Если фильтровать агрегаты – `HAVING` (фильтрация агрегатов после группировки ( в отличие от `WHERE`))

`**COUNT**(*)` – считает количество строк
**`SUM(column)`** – считает сумму значений в столбце
**`AVG(column)`** – считает среднее значение
**`MAX(column)` / `MIN(column)`** – ищут максимум и минимум

А.Ф. нужны, чтобы считать суммы, средние, максимальные и минимальные значения, количество записей. 


### **Основные концепции SQL**

SQL – это язык управления базами данных, используемый для выполнения операций с таблицами, такими как выборка, обновление, удаление, а также управление структурой данных. Здесь подробно описаны ключевые элементы, включая операторы, джоины, подзапросы, алиасы, ключи, ограничения, нормализацию и дополнительные концепции, такие как суррогатный ключ, сложные джоины и оператор BETWEEN.

---

#### **Операторы SQL**

Операторы помогают фильтровать данные или выполнять вычисления:

- **Сравнительные операторы:** `=`, `>`, `<`, `>=`, `<=`, `!=` (или `<>`).
- **Логические операторы:** `AND`, `OR`, `NOT` (комбинируют условия).
- **Арифметические операторы:** `+`, `-`, `*`, `/`.
- **Оператор IN:** Проверяет принадлежность значения множеству:
    
    ```sql
    SELECT * FROM users WHERE id IN (1, 2, 3);
    ```
    
- **LIKE:** Ищет шаблоны в текстовых полях:
    
    ```sql
    SELECT * FROM users WHERE name LIKE 'A%';
    ```
    
- **BETWEEN:** Позволяет фильтровать значения в диапазоне, включая границы:
    
    ```sql
    SELECT * FROM orders WHERE total_amount BETWEEN 100 AND 500;
    ```
    

---

#### **Суррогатный ключ**

**Суррогатный ключ** – это искусственный столбец, служащий уникальным идентификатором строки. Примером может быть автоинкрементируемый идентификатор (`ID`), который не несет бизнес-смысла, но обеспечивает уникальность записей.

**Пример:**

```sql
CREATE TABLE users (
    user_id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100)
);
```

Использование суррогатных ключей упрощает создание внешних ключей и управление данными в больших системах.

---

#### **Джоины (JOIN)**

`JOIN` используется для объединения данных из нескольких таблиц на основе связей между ними:

1. **INNER JOIN:** Возвращает только строки, совпадающие в обеих таблицах:
    
    ```sql
    SELECT users.name, orders.id
    FROM users
    INNER JOIN orders ON users.id = orders.user_id;
    ```
    
2. **LEFT JOIN:** Возвращает все строки из левой таблицы и совпадающие из правой. Если нет совпадения, добавляет `NULL` для правой таблицы:
    
    ```sql
    SELECT users.name, orders.id
    FROM users
    LEFT JOIN orders ON users.id = orders.user_id;
    ```
    
3. **RIGHT JOIN:** Возвращает все строки из правой таблицы и совпадающие из левой. Если совпадения нет, добавляет `NULL` для левой таблицы:
    
    ```sql
    SELECT users.name, orders.id
    FROM users
    RIGHT JOIN orders ON users.id = orders.user_id;
    ```
    
4. **FULL OUTER JOIN:** Возвращает все строки из обеих таблиц, добавляя `NULL`, где нет совпадений.
    

**Объединение более чем двух таблиц:**

```sql
SELECT u.name AS user_name, p.name AS product_name, o.order_date
FROM users u
INNER JOIN orders o ON u.user_id = o.user_id
INNER JOIN products p ON o.product_id = p.product_id;
```

Этот запрос соединяет данные из трех таблиц: `users`, `orders` и `products`. Если нужно включить строки без совпадений, можно комбинировать с `LEFT JOIN`.

---

#### **Подзапросы (Subqueries)**

Подзапрос – это вложенный запрос, результат которого используется внешним запросом:

- **Пример:** Найти пользователей с самым высоким заказом:
    
    ```sql
    SELECT name
    FROM users
    WHERE id = (
        SELECT user_id
        FROM orders
        ORDER BY total DESC
        LIMIT 1
    );
    ```
    

Подзапросы могут быть вложены в `SELECT`, `WHERE`, `FROM` и другие части запроса.

---

#### **Алиасы (Aliases)**

Алиасы используются для сокращения имен таблиц или столбцов:

- **Пример:**
    
    ```sql
    SELECT u.name AS user_name, o.id AS order_id
    FROM users AS u
    INNER JOIN orders AS o ON u.id = o.user_id;
    ```
    

Алиасы упрощают чтение запросов, особенно при работе с длинными именами.

---

#### **Ключи**

1. **Первичный ключ (Primary Key):** Уникальный идентификатор строки. Пример:
    
    ```sql
    CREATE TABLE users (
        id INT PRIMARY KEY,
        name VARCHAR(100)
    );
    ```
    
2. **Внешний ключ (Foreign Key):** Поле, указывающее на первичный ключ другой таблицы. Пример:
    
    ```sql
    CREATE TABLE orders (
        id INT PRIMARY KEY,
        user_id INT,
        FOREIGN KEY (user_id) REFERENCES users(id)
    );
    ```
    

---

#### **Ограничения (Constraints)**

Ограничения обеспечивают целостность данных:

- **NOT NULL:** Поле не может быть пустым.
- **UNIQUE:** Значения поля должны быть уникальны.
- **CHECK:** Задает условие для значений:
    
    ```sql
    CHECK (age >= 18)
    ```
    
- **DEFAULT:** Устанавливает значение по умолчанию:
    
    ```sql
    DEFAULT 'Active'
    ```
    

---

#### **Нормализация (1-3 НФ)**

Нормализация минимизирует дублирование данных и улучшает структуру базы:

1. **Первая нормальная форма (1НФ):** Таблица должна содержать только атомарные (неделимые) значения.
2. **Вторая нормальная форма (2НФ):** Все неключевые атрибуты зависят от первичного ключа.
3. **Третья нормальная форма (3НФ):** Убирает транзитивные зависимости (неключевые атрибуты не зависят друг от друга).

---

#### **Дополнительно**

1. **Индексы:** Ускоряют поиск данных: Ускорение поиска получения выборки
    
    ```sql
    CREATE INDEX idx_user_name ON users(name);
    ```
    