
https://novosibirsk.hh.ru/vacancy/118347515?hhtmFrom=employer_vacancies

##### **Актуализация и поддержка тестовой модели + знание TMS (желательно TestIT)**

##### **Присутствует опыт работы с оркестраторами (docker-portainer / kubernetes (k8s) / openshift)**
##### **Знание баг-трекинг систем (Jira)**
##### **Знание клиент-серверного взаимодействия**

**Клиент-сервер — это когда у тебя есть фронт и бэк.**

1. **Фронт** – мобильное приложение или веб-страница. Оно отправляет запросы на сервер.
2. **API** – мостик между фронтом и бэком. Форматы: REST, GraphQL, gRPC. Инструменты: Postman, Swagger.
3. **Бэк** – сервер, который принимает запросы и работает с базами, логикой и т.д.
    - Код (например, на Java, Python, Node.js).
    - База данных (SQL – PostgreSQL/MySQL, NoSQL – MongoDB/Redis).
    - Очереди сообщений (Kafka, RabbitMQ) – если надо обрабатывать данные асинхронно.
    - Кэширование (Redis, Memcached) – чтобы работало быстрее.
4. **Облако** – сервера, базы и хранилища в AWS/GCP/Azure.

Если коротко, клиент отправляет запрос → API передаёт на бэк → бэк обрабатывает → лезет в базу → даёт ответ. 
[[Структура клиент-серверной архитектуры]]
[[Архитектуры API]]
##### **Знание микросервисной архитектуры**

На каждой работе были микросервисы и высокая нагрузка.

**Микросервисная архитектура — это когда приложение не одной кучей, а разбито на мелкие независимые сервисы.**

1. **Каждый микросервис – это отдельная мини-программа**, которая делает свою работу (например, один отвечает за платежи, другой – за авторизацию).
2. **Они общаются друг с другом через API** (обычно REST, gRPC, очереди Kafka/RabbitMQ).
3. **Если один упал – остальные продолжают работать** (в отличие от монолита, где всё рушится).
4. **Разрабатывать и обновлять можно по отдельности** – удобно для больших команд.
5. **Деплой и масштабирование** – можно нагрузить только нужные части системы (например, если на платежи большая нагрузка, увеличиваем только этот сервис).

Главное – это **разделение, независимость и удобство масштабирования**.
##### **Опыт взаимодействия с внешними (относительно окружения микросервиса) системами + опыт интеграционного тестирования**

Ну вот недавно было. Моя команда переводит свой функционал из WebView (то есть веба) на натив (на Android и iOS) - компоненты. И этот, как бы, апдейт, он сильно аффектит некоторые другие команды. И вот эти команды, они тоже заинтересованы в том, чтобы проверить то, что все работает нормально. Мы тестировщики, из нескольких команд, все вместе проходим тест-кейсы, для того, чтобы сделать регрессионное и со своей стороны выявить наличие возможных ошибок или рисков. Ну или их отсутствие.

Иногда 2 или 3 команды могут совместный функционал делать в рамках спринта или нескольких кварталов. 

Изначально я составлял тест-кейсы ,исходя из того, что мне нужно проверить. Для этого мне пришлось почитать документацию в конфлюенсе, написанную моим системным аналитиком. Эта документация, она про бизнес-логику прежде всего, про взаимодействие между микросервисами различными и тому, какие там данные должны входить, какие выходить из одного микросервиса в другой, и каким образом маппиться. 

Плюс смотрел макеты Figma, то есть как экраны выглядят на фронте UI, и еще там же кейсы позитивные, негативные.  Большинство были описаны.

После этого всего я написал тест-кейсы, я потом показал своему системному аналитику из команды. Он посмотрел, сказал: «Да, норм" и пару правок там каких-то сказал сделать, не помню уже. 

После этого я писал главному бизнес-аналитику в Доме, он валидировал мои тест-кейсы, и там тучу правок всяких еще внес.

Так вот, после этого всего, я получил аппрув от главного бизнес-аналитика по этим тест-кейсам. И, по сути, ими пользовались другие тестировщики из других команд. **Я** это делал, потому что моя команда функционал меняла.


##### **Формирование отчетов по результатам тестирования**

**Отчеты**: берешь, пишешь тест-кейсы, затем тестируешь какой либо функционал, проставил статусы по типу “пройдено”, “не пройдено”, все протыкал, весь тест-план завершается и вот тебе отчет. В TestIT все это оформляем.  

**Баг-репорт**. Я делаю как. Я иду в треккер. Создаю таску. Т.к. баг репорт похож на тест-кейс. Предусловия, шаги и ожидаемый рез можно просто скопировать с тест-кейса.

Например не совпал ожидаемый рез: добавляем атрибут - фактический рез и пишем, что кнопка не работает. 

Далее, добавляю заголовок по формуле где? что? когда? (при каких условиях)

Авторизация. При вводе некорректных данных не происходит то-то 

Можно добавить окружение: операционка, версия браузера, разрешение экрана, версию браузера если это сайт

На мобилке: это ОС, версия ОС, марка модель устр-ва, версия приложения

Можно добавить скрин или запись экрана
##### **Владение sql на уровне выборки из нескольких таблиц + агрегатных функций**
##### **Владение swagger/postman/иной инструмент**
##### **Умение анализировать логи (браузера и сервера)**

 **Логи браузера (Frontend)**
 
Смотрим в **DevTools (F12 → Console/Network)**:
1. **Ошибки в консоли** (красные) – например, `Uncaught TypeError: Cannot read property 'name' of undefined`.
2. **Запросы в Network** – отправляются ли, какие статусы (`200 OK` – норм, `500` – сервер упал, `404` – не нашли).
3. **Ответы от сервера** – корректные ли данные приходят или там ошибка.
4. **Performance** – долго грузится? Где затык?

**Алгоритм работы**:

- **Шаг 1**: Найдите ошибку или проблему.
- **Шаг 2**: Проверьте логи браузера для обнаружения JavaScript-ошибок, запросов, которые не были выполнены или вернули ошибку.
- **Шаг 3**: Перейдите к логам сервера для получения более подробной информации о запросах, связанных с ошибками.
- **Шаг 4**: Анализируйте таймлайны и зависимости между запросами, чтобы найти узкие места и проблемы с производительностью.
##### **MQ: Желателен опыт работы с kafka**
Kafka - не тестил, но знаешь что это и зачем. Для асинхронности. Если бы надо было тестить - можно было бы посмотрть события в условной кибане, по условному айдишнику.
##### **Знакомство с jenkins\teamcity\иной инструмент**

Иногда перезапускал пайплайны с билдами приложений или автотестов, если что-то слетало. 
 
 **Jenkins**
 Один из самых популярных инструментов **CI/CD** с открытым исходным кодом.

 **Ключевые возможности:**
✔ Автоматизация сборки, тестирования и развертывания.  
✔ Поддержка **плагинов** (Git, Docker, Kubernetes и др.).  
✔ Работа с **Jenkinsfile** (Pipeline-as-Code).  
✔ Запуск тестов (юнит, интеграционные, автотесты).  
✔ Поддержка **параллельных билдов**.

**Как работает Jenkins:**
1. Код коммитится в репозиторий (**Git**).  
2.  Jenkins триггерит билд (например, через **webhook**).  
3. Запускается **сборка проекта**.  
4. Выполняются тесты (**Selenium, Pytest, JUnit**).  
5. Развёртывание на сервер (если билд успешен).

[[Конфигурация GitLab CI для автотестов на Python]]
##### **k8s (kubernetes\openshift), управление микросервисами (deployment\help\configmap), управление окружением (env-config) (необязательно).**
##### **Знакомство с git\bitbucket\иной инструмент (необязательно).**
##### **Приветствуется: опыт ведения демо\ПСИ для бизнес-заказчиков**
##### **Присутствует опыт тестирования backend операций / api**

##### **Присутствует опыт работы с БД SQL, соединение 2-х и более таблиц джоинами и подзапросами**

##### **Присутствует опыт работы хотя бы с одним брокером сообщений (kafka / rabbit / jms)**

##### **Глубокое понимание рестфул сервисов**