## **!!БОЛЬШИНСТВО ПРОБЛЕМ В АВТОТЕСТАХ ВОЗНИКАЕТ ИЗ-ЗА ЗАПУСКА НЕ НА LINUX!!**

#### 1. **Проблема с текущей директорией проекта**

**Суть проблемы:**

- Проект изначально находился не в стандартной директории, что приводило к путанице с путями.

**Решение:**

- Директория проекта была перенесена в стандартное место:
    
    `C:\Users\allin\PythonProject`
    
- Для работы в терминале переключались в эту папку командой:
    
    `cd "C:\Users\allin\PythonProject"`
    

---

#### 2. **Виртуальное окружение**

**Суть проблемы:**

- Было пару каких то непоняток, просто снес папку venv и пересоздал окружение.

**Действия:**

- Создание окружения:
    
    `python -m venv venv`
    
- Активация окружения:
    
    `.\venv\Scripts\activate`
    

---

#### 3. **Проблема с `chromedriver`**

**Суть проблемы:**

- `chromedriver` не идет в комплекте с браузером и не обновляется автоматически. Его нужно скачивать отдельно по правильной ссылке, соответствующей версии браузера.
- Также `chromedriver` изначально не был добавлен в `PATH`.
- В новых версиях Selenium использование аргумента `executable_path` устарело, и вместо него нужно применять класс `Service`.

**Решение:**

- Скачать `chromedriver` для своей версии браузера (в данном случае 131.0.6778.205) с официального сайта https://googlechromelabs.github.io/chrome-for-testing/#stable
- Добавить папку с `chromedriver` в переменную среды `PATH`, чтобы можно было вызывать его без указания полного пути:
    1. Перейти в настройки системы → Переменные среды.
    2. Найти переменную `PATH` и добавить туда путь к папке:
        
        `C:\Program Files\Google\Chrome\Application\131.0.6778.205\chromedriver-win64`
        
- Проверить работу драйвера командой:
    
    `chromedriver --version`
    
- Для корректной работы с Selenium использовать класс `Service`:
    
    ![[Pasted image 20250106151325.png]]
    

---

#### 4. **Проблема с тестами на API**

**Суть проблемы:**

- Тесты зависели от внешнего сервера (`http://localhost:8888/api/employees`), который не был запущен, из-за чего возникала ошибка `ConnectionRefusedError`.

**Решение:**

- Для тестирования использовали библиотеку `unittest.mock`, чтобы подменить реальный HTTP-запрос фиктивным ответом.

**Пример исправленного теста:**

![[Pasted image 20250106151358.png]]
**Что было сделано:**

- Подменили вызов `requests.post` через декоратор `@patch`.
- Указали фиктивный ответ с кодом 200 и заранее определенным JSON-объектом.
- Проверили, что мок возвращает ожидаемые значения.

## С Allure вроде получилось
![[Pasted image 20250106152120.png]]


**Итого**. 

![[Pasted image 20250106152701.png]]

1. Инструкция "AQA пошагово" требует серьезных доработок. Делать этого я конечно же не буду. Мучаем AI, он все знает. 

2. Были проблемы с директориями, но это больше мои причуды, т.к. они были все по дефолтных путях.  

3. С библиотеками и виртуальным окружением проблем +- не было

4. Хромдрайвер вынес весь мозг. Все казалось просто, оказалось сложно, но по факту - просто! 

5. При тестах бэкэнда GPT ранее сгенерировал фейковую ссылку или что-то в этом духе, не разбирался. Подменил запрос через библиотеку mock и все норм, через него же. 

6. Что-то еще было, я уже не помню. GPT был весь измучен, свои 20$ отработал. В самом наполнении (код) я не разбирался, но общий процесс понятен.  


## Резюме. Как автотесты должны работать.
#### **1. Подготовка данных для теста**

Любой автотест работает с определёнными данными. Например:

- Вы создаёте тестовые данные (например, информацию о сотруднике) в файле `test_data.py`:
    
![[Pasted image 20250106153808.png]]
    
    Эти данные — это то, что вы будете отправлять в тестируемую систему. Здесь мы проверяем, что сотрудник с указанными параметрами (имя, возраст, должность) правильно создаётся в системе.

---

#### **2. Взаимодействие с тестируемой системой**

Для взаимодействия с системой (например, сервером или API) вы создаёте специальный инструмент — **API-клиент**. Он описан в файле `client.py`:

![[Pasted image 20250106153827.png]]
- **Что он делает?**
    - Отправляет HTTP-запросы (например, `POST`) на сервер.
    - Передаёт тестовые данные (например, данные сотрудника) на сервер.
    - Получает ответ от сервера, который можно проверить.

---

#### **3. Проверка результата (сам тест)**

Тест написан в файле `test_create_employee.py`. Вот его структура:

![[Pasted image 20250106153843.png]]

- **Как он работает?**
    - Вызывается метод `create_employee` из `APIClient`, чтобы отправить данные сотрудника.
    - Сервер возвращает ответ — например, созданные данные сотрудника.
    - Через `assert` вы проверяете, совпадают ли данные в ответе с вашими ожиданиями. Если что-то не совпадает, тест завершается с ошибкой.

---

#### **4. Что если нет сервера?**

Если реального сервера нет, тесты всё равно можно выполнить, используя **моки** (заменители сервера). Это позволяет "обмануть" тест, чтобы он работал, будто сервер отвечает. Пример:

![[Pasted image 20250106153903.png]]

- **Что происходит здесь?**
    - Вместо реального запроса к серверу используется мок (симуляция ответа сервера).
    - Мок возвращает "фальшивый" ответ, который вы заранее задаёте.
    - Тест проверяет "ответ" от мока так же, как если бы это был настоящий сервер.

---

#### **5. Генерация отчетов (Allure)**

После выполнения тестов важно видеть, какие из них прошли, а какие — нет. Для этого используется инструмент **Allure**.

**Как он работает?**

1. Вы добавили файл `pytest.ini`, который автоматически сохраняет результаты тестов в папке `reports`:
![[Pasted image 20250106153925.png]]
    
2. После запуска тестов с `pytest` в папке `reports` создаются отчёты.
3. Чтобы просмотреть отчёты в удобном виде, вы запускаете команду:
    
    `allure serve reports`
    
    Это открывает браузер с красивыми диаграммами, списками успешных и проваленных тестов.



## Итого вы:

- **Создаёте тестовые данные.**
- **Отправляете запрос через API-клиент.**
- **Проверяете результат через `assert`.**
- **Генерируете Allure-отчёты.**
- **Просматриваете отчёты для анализа.**