## **Кратко**

- **Итераторы**: класс с методами `__iter__()` и `__next__()`.
- **Генераторы**: функции с `yield`, запоминающие состояние между вызовами.
- **Итераторы и генераторы** экономят память, работая с данными "лениво".
---


## **Долго**

#### **Итераторы:**

- Объекты, которые возвращают элементы по одному.
- Реализуют методы:
    - **`__iter__()`** – возвращает сам итератор.
    - **`__next__()`** – возвращает следующий элемент.

#### **Генераторы:**

- Упрощённый способ создания итераторов.
- Используют ключевое слово **`yield`** для сохранения состояния.

---

##### **Пример итератора:**

```python
class MyIterator:
    def __init__(self, limit):
        self.limit = limit
        self.counter = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.counter < self.limit:
            self.counter += 1
            return self.counter
        raise StopIteration

for i in MyIterator(3):  # 1, 2, 3
    print(i)
```

---


##### **Пример генератора:**

```python
def my_generator():
    for i in range(3):
        yield i

for i in my_generator():  # 0, 1, 2
    print(i)
```

##### **Разница между `return` и `yield`:**

- `return` завершает функцию.
- `yield` сохраняет состояние и возвращает управление в функцию при следующем вызове.

---

#### **Использование `next()`:**

```python
gen = my_generator()
print(next(gen))  # 0
print(next(gen))  # 1
```

